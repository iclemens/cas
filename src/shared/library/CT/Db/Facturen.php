<?php
	/**
	 * Provides an interface to the 'facturen' (invoices) table.
 	 *
	 * @author     Ivar Clemens <post@ivarclemens.nl>
	 * @package    CT_Db
	 */

	Zend_Loader::loadClass('Zend_Db_Table');
	Zend_Loader::loadClass('CT_Db_Factuurregels');
	Zend_Loader::loadClass('CT_Db_Factureren');

	/**
	 * Provides an interface to the 'facturen' (invoices) table.
	 *
	 * Arrays containing invoice-related data are being used extensively
	 * within cas. Even though all these array-variables go by the name
	 * of $factuur, they may contain some very different fields.
	 *
	 * What follows is a list of _all_ fields in use by CAS, what they
	 * mean and how they are used. Note that only the minimal set of
	 * fields and the 'regels' array (without 'ref') are being stored 
	 * in the database on insertion.
	 *
	 * @todo This part probably belongs in a more generic place.
	 * @todo In the future, we might want to split some of this off and start using the row-data-gateway pattern.
	 *
	 * Minimum invoice specification:
	 * - 'klantnummer' - The customer id.
	 * - 'datum'			 - The date the invoice was created (yyyy-mm-dd).
	 * - 'korting'		 - The discount in cents or percents (depending on kortingtype).
	 * - 'btw_percentage' - The percentage of VAT
	 *
	 * Optional fields: (required for insertion)
	 * - 'regels'			 - Array of lines
	 *   - 'ref'       - Reference to factureren entry
	 *
	 * Optional fields: (present when retreived from the database)
	 * - 'volgnummer'			- The invoice id
	 * - 'factuurnummer'	- The number identifying this invoice within the financial year.
	 *
	 * Optional fields:
	 * - 'kortingtype'    - Either 'absolute' (korting in cents) or 'relative' (korting in percents).
	 *                      If this field is not present, absolute is assumed!
	 *
	 * Calculated fields: (produced by addCalculatedFields)
	 * - 'korting_bedrag' - The discount in cents.
	 * - 'subtotaal'      - The total excluding VAT
	 * - 'btw'						- The total amount of VAT
	 * - 'totaal'					- The total including VAT
	 * 
	 * @package CT_Db 
	 */
	class CT_Db_Facturen extends Zend_Db_Table 
	{ 
		/**
		 * The name of the table.
		 * @var _name
		 */
		protected $_name = 'facturen';


		/**
		 * The primary key of the table.
		 * @var _primary
		 */
		protected $_primary = 'volgnummer';


		/**
		 * Finds the first free invoice number.
		 *
		 * WARNING: Lock the database table before using this function!
		 *          If two processes try to generate an invoice id at the
		 *				  same time, the database could become invalid.
		 *
 		 * @param int	$boekjaar Financial year of the invoice.
		 * @return int The first free invoice number in the given financial year.
		 */
		private function _volgendFactuurnummer($boekjaar) {

			$db = $this->getAdapter();
			$result = $db->query("SELECT factuurnummer + 1 AS volgendnummer " .
				"FROM facturen WHERE YEAR(datum)=:boekjaar " .
				"ORDER BY factuurnummer DESC LIMIT 1",
				array("boekjaar" => $boekjaar));
		
			$rows = $result->fetchAll();

			/* An empty (starting) financial year yields no results */
			if(count($rows) != 1)
				return 1;

			$row = $rows[0];
			return $row['volgendnummer'];
		}


		/**
		 * Retreives an invoice given both the financial year and it's number.
		 *
		 * @param	int $boekjaar Financial year.
		 * @param int $factuurnummer Invoice number.
		 * @return array The invoice.
		 */
		public function findByFactuurnummer($boekjaar, $factuurnummer)
		{
			$db = $this->getAdapter();
			$where = array($db->quoteInto('YEAR(datum) = ?', intval($boekjaar)),
						 		$db->quoteInto('factuurnummer = ?', intval($factuurnummer)));

			$rows = $this->fetchAll($where)->toArray();

			if(count($rows) != 1)
				return false;

			$row = $rows[0];
			return $row;
		}


		/**
		 * Adds a new invoice to the database.
		 *
 		 * @param  array $factuur	The new invoice.
		 * @return int The id of the invoice (this is different from the invoice number).
		 */
		public function insert(array $factuur) 
		{
			/* The default invoice specification is not compatible with
				the database structure. Here we split the invoice lines
				from the rest of the invoice for easy processing */

			if(array_key_exists('kortingtype', $factuur) && $factuur['kortingtype'] == 'relative') {
				$tmp = CT_Db_Facturen::addCalculatedFields($factuur);
				$factuur['korting'] = $tmp['korting_bedrag'];
			}

			unset($factuur['kortingtype']);

			$factuur_regels = $factuur['regels'];
 			unset($factuur['regels']);

			$fr_table = new CT_Db_Factuurregels();
			$fe_table = new CT_Db_Factureren();
			$db = $this->getAdapter();

			// Prevent duplicate invoice numbers from being generated by locking the table!
			//$db->query('LOCK TABLES factuur');
			$db->beginTransaction();

			try {
				$factuur['factuurnummer'] = $this->_volgendFactuurnummer(date('Y', strtotime($factuur['datum'])));

				$volgnummer = parent::insert($factuur);
			
				if(is_array($factuur_regels)) {
					foreach($factuur_regels as $key => $factuur_regel) {

						/* First remove base data */
						if(array_key_exists('ref', $factuur_regel)) {
							$factureren_ref = $factuur_regel['ref'];
							unset($factuur_regel['ref']);
						} else {
							$factureren_ref = 0;
						}
						
						if(intval($factureren_ref) > 0) {
							$fe_table->delete($fe_table->getAdapter()->quoteInto(
								'volgnummer = ?', intval($factureren_ref)));
						}

						/* Then, insert new line into the database */
						$factuur_regel['factuurvolgnummer'] = $volgnummer;
						$factuur_regel['factuurregel'] = $key;
	
						if($factuur_regel['omschrijving'] != '')
							$fr_table->insert($factuur_regel);
					}
				}

				$db->commit();
				//$db->query('UNLOCK TABLES');
			} catch (Exception $e) {
				$db->rollBack();
				//$db->query('UNLOCK TABLES');
				throw $e;
			}

			return $volgnummer;
		}


		/**
		 * Adds calculated fields (such as totals) to an invoice definition.
		 *
 		 * @param array $factuur An invoice.
		 * @return array The invoice containing calculated fields.
		 */
		static function addCalculatedFields($factuur)
		{
			$subtotaal = 0;

			// Only fetch lines if not already present...
			if(!is_array($factuur['regels']) ) {
				$tbl_regels = new CT_Db_Factuurregels();
				
				$where = $tbl_regels->getAdapter()->quoteInto("factuurvolgnummer = ?", $factuur['volgnummer']);
				$factuur_regels = $tbl_regels->fetchAll($where)->toArray();
				$factuur['regels'] = $factuur_regels;
			}

			foreach($factuur['regels'] as &$regel) {
				if($regel['aantal'] == NULL)
					$regel['totaal'] = floor(1 * $regel['prijs'] + 0.5);
				else
					$regel['totaal'] = floor($regel['aantal'] * $regel['prijs'] + 0.5);

				$subtotaal += $regel['totaal'];
			}

			if(array_key_exists('korting', $factuur)) {
				if(array_key_exists('kortingtype', $factuur) && $factuur['kortingtype'] == 'relative') {
					$factuur['korting_bedrag'] = floor($factuur['korting'] * $subtotaal / 100 + 0.5);
				} else {
					$factuur['korting_bedrag'] = $factuur['korting'];
				}
			} else {
				$factuur['korting_bedrag'] = 0;
			}

			$subtotaal = $subtotaal - $factuur['korting_bedrag'];

			// Assume 0%
			if(!array_key_exists('btw_percentage', $factuur))
				$factuur['btw_percentage'] = 0;

			$btw = floor($subtotaal * $factuur['btw_percentage'] / 100 + 0.5);
			$factuur['subtotaal'] = $subtotaal;
			$factuur['btw'] = $btw;
			$factuur['totaal'] = $subtotaal + $btw;

			return $factuur;
		}

		
		/**
		 * Creates a basic SQL query which extracts all invoice data from the database,
		 * including the total amount per invoice. Use the Zend_Db_Select API to
		 * extend this query with filter or storing parameters.
		 *
		 * @param Zend_Db_Select $query Query to extend, based on CT_Db_Facturen->select()
		 *
		 * @return Zend_Db_Select The basic invoice query
		 */
		public function getBasicQuery($query = NULL)
		{
			if(!isset($query) || $query == NULL) {
				$query = $this->select();
			}
			
			$sql_totaal_regel = "FLOOR((IFNULL(aantal, 1) * prijs) + 0.5)";
			$sql_subtotaal = "(FLOOR(SUM($sql_totaal_regel) + 0.5) - korting)";
			$sql_btw = "FLOOR(($sql_subtotaal * btw_percentage / 100) + 0.5)";
			$sql_totaal = "($sql_subtotaal + $sql_btw)";		

			$query->setIntegrityCheck(false)
				->from('facturen',
					array(
					'facturen.volgnummer',
					'facturen.factuurnummer',
					'facturen.datum',
					'facturen.uiterstedatum',
					'facturen.korting',
					'facturen.btw_percentage',
					'facturen.incasso',
					'subtotaal' => $sql_subtotaal,
					'btw' => $sql_btw,
					'totaal' => $sql_totaal,
					'leeftijd' => 'DATEDIFF(NOW(), datum)'))
				->join('factuurregels', 'facturen.volgnummer = factuurregels.factuurvolgnummer', array())
				->join('klanten', 'facturen.klantnummer = klanten.klantnummer', 
					array('bedrijfsnaam', 'aanhef', 'voornaam', 'achternaam', 'actief', 'klanttype'));
						
			$query = $query->group('facturen.volgnummer');

			return $query;
		}
		
	}
